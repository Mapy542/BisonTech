{"mode":"Text","textContent":"#pragma region VEXcode Generated Robot Configuration\n#pragma region VEXcode Generated Robot Configuration\n// Make sure all required headers are included.\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n#include <math.h>\n#include <string.h>\n\n\n#include \"vex.h\"\n\nusing namespace vex;\n\n// Brain should be defined by default\nbrain Brain;\n\n\n// START V5 MACROS\n#define waitUntil(condition)                                                   \\\n  do {                                                                         \\\n    wait(5, msec);                                                             \\\n  } while (!(condition))\n\n#define repeat(iterations)                                                     \\\n  for (int iterator = 0; iterator < iterations; iterator++)\n// END V5 MACROS\n\n\n// Robot configuration code.\nmotor FL = motor(PORT19, ratio18_1, false);\n\nmotor RL = motor(PORT20, ratio18_1, false);\n\nmotor FR = motor(PORT9, ratio18_1, true);\n\nmotor RR = motor(PORT10, ratio18_1, true);\n\ncontroller Controller1 = controller(primary);\ninertial Gyroscope = inertial(PORT18);\n\nencoder y = encoder(Brain.ThreeWirePort.A);\nencoder x = encoder(Brain.ThreeWirePort.C);\nmotor LiftLeft = motor(PORT7, ratio18_1, false);\n\nmotor LiftRight = motor(PORT6, ratio18_1, true);\n\nmotor BaseLock = motor(PORT17, ratio18_1, true);\n\n\n\n\n// define variable for remote controller enable/disable\nbool RemoteControlCodeEnabled = true;\n#pragma endregion VEXcode Generated Robot Configuration\n\n#include \"vex.h\"\n  \n// Allows for easier use of the VEX Library\nusing namespace vex;\n\ncompetition Competition;\n\n// User defined function\nvoid myblockfunction_Send_Lift_to_position_r(double myblockfunction_Send_Lift_to_position_r__r);\n// User defined function\nvoid myblockfunction_Set_Offset_x_y(double myblockfunction_Set_Offset_x_y__x, double myblockfunction_Set_Offset_x_y__y);\n// User defined function\nvoid myblockfunction_Manuel_Other_Functions();\n// User defined function\nvoid myblockfunction_ManualControl();\n// User defined function\nvoid myblockfunction_Auto_Extra_Functions();\n// User defined function\nvoid myblockfunction_destination_x_y_r_at_power_speed(double myblockfunction_destination_x_y_r_at_power_speed__x, double myblockfunction_destination_x_y_r_at_power_speed__y, double myblockfunction_destination_x_y_r_at_power_speed__r, double myblockfunction_destination_x_y_r_at_power_speed__speed);\n// User defined function\nvoid myblockfunction_waypoint_x_y_r_at_power_speed(double myblockfunction_waypoint_x_y_r_at_power_speed__x, double myblockfunction_waypoint_x_y_r_at_power_speed__y, double myblockfunction_waypoint_x_y_r_at_power_speed__r, double myblockfunction_waypoint_x_y_r_at_power_speed__speed);\n// User defined function\nvoid myblockfunction_Calculate_Degrees_to_deg_from_gyro_reading(double myblockfunction_Calculate_Degrees_to_deg_from_gyro_reading__deg);\n// User defined function\nvoid myblockfunction_Poll_Absolute_Cords();\n// User defined function\nvoid myblockfunction_Print_XYR();\n// User defined function\nvoid myblockfunction_Lock_Base();\n// User defined function\nvoid myblockfunction_Unlock_Base();\n// User defined function\nvoid myblockfunction_drive_motos_at_x_y_r_s_x_y_r_s(double myblockfunction_drive_motos_at_x_y_r_s_x_y_r_s__x, double myblockfunction_drive_motos_at_x_y_r_s_x_y_r_s__y, double myblockfunction_drive_motos_at_x_y_r_s_x_y_r_s__r, double myblockfunction_drive_motos_at_x_y_r_s_x_y_r_s__s);\n\nint Brain_precision = 0, Console_precision = 0, Controller1_precision = 0;\n\nfloat ForwardMultiplier, TurnMultiplier, TranslateMultiplier, TargetDegree, CorrectionMultiplier, CurrentXAxis, EncoderDeltaX, PreviousXValue, EncoderDeltaY, PreviousYValue, CurrentYAxis, RampUp, RampDown, DriveXPower, DriveYPower, DriveRPower, DriveXDir, DriveYDir, DriveYScale, DriveXScale, DriveRScale, DegreeDiff, TangentialDist, DeltaTheta, PreviousTheta, LiftDegrees, LockDesiredHeading;\n\n// User defined function\nvoid myblockfunction_Send_Lift_to_position_r(double myblockfunction_Send_Lift_to_position_r__r) {\n  LiftLeft.spinToPosition(myblockfunction_Send_Lift_to_position_r__r, degrees, false);\n  LiftRight.spinToPosition(myblockfunction_Send_Lift_to_position_r__r, degrees, true);\n}\n\n// User defined function\nvoid myblockfunction_Set_Offset_x_y(double myblockfunction_Set_Offset_x_y__x, double myblockfunction_Set_Offset_x_y__y) {\n  CurrentXAxis = myblockfunction_Set_Offset_x_y__x;\n  CurrentYAxis = myblockfunction_Set_Offset_x_y__y;\n}\n\n// User defined function\nvoid myblockfunction_Manuel_Other_Functions() {\n  if (Controller1.ButtonR1.pressing()) {\n    if (LiftLeft.rotation(degrees) < 1500.0) {\n      LiftLeft.spin(forward);\n    }\n    else {\n      LiftLeft.stop();\n    }\n    if (LiftRight.rotation(degrees) < 1500.0) {\n      LiftRight.spin(forward);\n    }\n    else {\n      LiftRight.stop();\n    }\n  } else if (Controller1.ButtonL1.pressing()) {\n    if (-600.0 < LiftLeft.rotation(degrees)) {\n      LiftLeft.spin(reverse);\n    }\n    else {\n      LiftLeft.stop();\n    }\n    if (-600.0 < LiftRight.rotation(degrees)) {\n      LiftRight.spin(reverse);\n    }\n    else {\n      LiftRight.stop();\n    }\n  } else {\n    LiftLeft.stop();\n    LiftRight.stop();\n    if (LiftLeft.rotation(degrees) < LiftRight.rotation(degrees)) {\n      LiftRight.stop();\n      LiftLeft.setVelocity(100.0, percent);\n      LiftLeft.spinToPosition(LiftRight.rotation(degrees), degrees, false);\n    }\n    else {\n      LiftLeft.stop();\n      LiftRight.setVelocity(100.0, percent);\n      LiftRight.spinToPosition(LiftLeft.rotation(degrees), degrees, false);\n    }\n  }\n  if (3.0 > fabs(static_cast<float>(BaseLock.rotation(degrees) - LockDesiredHeading)) && Controller1.ButtonA.pressing()) {\n    if (LockDesiredHeading > 35.0) {\n      LockDesiredHeading = 0.0;\n    }\n    else {\n      LockDesiredHeading = 45.0;\n    }\n  }\n  if (fabs(static_cast<float>(BaseLock.rotation(degrees) - LockDesiredHeading)) > 2.0) {\n    BaseLock.spinToPosition(LockDesiredHeading, degrees, false);\n  }\n  else {\n    BaseLock.stop();\n  }\n}\n\n// User defined function\nvoid myblockfunction_ManualControl() {\n  if (!(Controller1.Axis3.position() == 0.0) || (!(Controller1.Axis1.position() == 0.0) || !(Controller1.Axis4.position() == 0.0))) {\n    FL.setVelocity((((Controller1.Axis3.position() * ForwardMultiplier + Controller1.Axis4.position() * TranslateMultiplier) - Controller1.Axis1.position() * TurnMultiplier) + CorrectionMultiplier), percent);\n    FL.spin(forward);\n    RL.setVelocity((((Controller1.Axis3.position() * ForwardMultiplier + Controller1.Axis4.position() * TranslateMultiplier) + Controller1.Axis1.position() * TurnMultiplier) + CorrectionMultiplier), percent);\n    RL.spin(forward);\n    FR.setVelocity((((Controller1.Axis3.position() * ForwardMultiplier - Controller1.Axis4.position() * TranslateMultiplier) + Controller1.Axis1.position() * TurnMultiplier) - CorrectionMultiplier), percent);\n    FR.spin(forward);\n    RR.setVelocity((((Controller1.Axis3.position() * ForwardMultiplier - Controller1.Axis4.position() * TranslateMultiplier) - Controller1.Axis1.position() * TurnMultiplier) - CorrectionMultiplier), percent);\n    RR.spin(forward);\n  }\n  else {\n    FL.stop();\n    RL.stop();\n    FR.stop();\n    RR.stop();\n  }\n}\n\n// User defined function\nvoid myblockfunction_Auto_Extra_Functions() {\n  if (fabs(static_cast<float>(LiftDegrees - LiftLeft.rotation(degrees))) > 5.0) {\n    if (LiftLeft.rotation(degrees) < LiftDegrees) {\n      LiftRight.spin(forward);\n      LiftLeft.spin(forward);\n    }\n    else {\n      LiftLeft.spin(reverse);\n      LiftRight.spin(reverse);\n    }\n  }\n  else {\n    LiftLeft.stop();\n    LiftRight.stop();\n  }\n}\n\n// User defined function\nvoid myblockfunction_destination_x_y_r_at_power_speed(double myblockfunction_destination_x_y_r_at_power_speed__x, double myblockfunction_destination_x_y_r_at_power_speed__y, double myblockfunction_destination_x_y_r_at_power_speed__r, double myblockfunction_destination_x_y_r_at_power_speed__speed) {\n  RampUp = 0.01;\n  TangentialDist = 0.0;\n  RampDown = 1.0;\n  myblockfunction_Calculate_Degrees_to_deg_from_gyro_reading(myblockfunction_destination_x_y_r_at_power_speed__r);\n  TangentialDist = 2.0 * (DegreeDiff * 6.2831);\n  if (0.15 < FL.velocity(percent) || (0.15 < RL.velocity(percent) || (0.15 < FR.velocity(percent) || 0.15 < RR.velocity(percent)))) {\n    RampUp = 1.0;\n  }\n  while (!((fabs(static_cast<float>(myblockfunction_destination_x_y_r_at_power_speed__y - CurrentYAxis)) < 10.0 && fabs(static_cast<float>(TangentialDist)) < 10.0) && fabs(static_cast<float>(myblockfunction_destination_x_y_r_at_power_speed__x - CurrentXAxis)) < 10.0)) {\n    // Calculate Odometry\n    myblockfunction_Poll_Absolute_Cords();\n    myblockfunction_Calculate_Degrees_to_deg_from_gyro_reading(myblockfunction_destination_x_y_r_at_power_speed__r);\n    TangentialDist = 2.0 * (DegreeDiff * 6.2831);\n    // Calculate Ramp Powers\n    RampUp = RampUp * 1.06;\n    if (1.0 < RampUp) {\n      RampUp = 1.0;\n    }\n    // Use quadratic functiion for ramp down\n    RampDown = ((fabs(static_cast<float>(myblockfunction_destination_x_y_r_at_power_speed__x - CurrentXAxis)) + fabs(static_cast<float>(myblockfunction_destination_x_y_r_at_power_speed__y - CurrentYAxis))) + 1.5 * fabs(static_cast<float>(TangentialDist))) * -0.015;\n    RampDown = (RampDown * RampDown + 15.0) / 100.0;\n    if (1.0 < RampDown) {\n      RampDown = 1.0;\n    }\n    // Calculate Scale for direct line\n    if (fabs(static_cast<float>(myblockfunction_destination_x_y_r_at_power_speed__x - CurrentXAxis)) < fabs(static_cast<float>(TangentialDist)) && fabs(static_cast<float>(myblockfunction_destination_x_y_r_at_power_speed__y - CurrentYAxis)) < fabs(static_cast<float>(TangentialDist))) {\n      DriveYScale = 100.0 * (fabs(static_cast<float>(myblockfunction_destination_x_y_r_at_power_speed__y - CurrentYAxis)) / fabs(static_cast<float>(TangentialDist)));\n      DriveXScale = 100.0 * (fabs(static_cast<float>(myblockfunction_destination_x_y_r_at_power_speed__x - CurrentXAxis)) / fabs(static_cast<float>(TangentialDist)));\n      DriveRScale = 50.0;\n    }\n    else {\n      if (fabs(static_cast<float>(myblockfunction_destination_x_y_r_at_power_speed__x - CurrentXAxis)) < fabs(static_cast<float>(myblockfunction_destination_x_y_r_at_power_speed__y - CurrentYAxis))) {\n        DriveYScale = 100.0;\n        DriveXScale = 100.0 * (fabs(static_cast<float>(myblockfunction_destination_x_y_r_at_power_speed__x - CurrentXAxis)) / fabs(static_cast<float>(myblockfunction_destination_x_y_r_at_power_speed__y - CurrentYAxis)));\n        DriveRScale = 50.0 * (fabs(static_cast<float>(TangentialDist)) / fabs(static_cast<float>(myblockfunction_destination_x_y_r_at_power_speed__y - CurrentYAxis)));\n      }\n      else {\n        DriveYScale = 100.0 * (fabs(static_cast<float>(myblockfunction_destination_x_y_r_at_power_speed__y - CurrentYAxis)) / fabs(static_cast<float>(myblockfunction_destination_x_y_r_at_power_speed__x - CurrentXAxis)));\n        DriveXScale = 100.0;\n        DriveRScale = 50.0 * (fabs(static_cast<float>(TangentialDist)) / fabs(static_cast<float>(myblockfunction_destination_x_y_r_at_power_speed__x - CurrentXAxis)));\n      }\n    }\n    // Solve for direction\n    if (fabs(static_cast<float>(myblockfunction_destination_x_y_r_at_power_speed__x - CurrentXAxis)) < 10.0) {\n      DriveXDir = 0.0;\n    }\n    else {\n      if (myblockfunction_destination_x_y_r_at_power_speed__x - CurrentXAxis < 0.0) {\n        DriveXDir = 1.0 * DriveXScale;\n      }\n      else {\n        DriveXDir = -1.0 * DriveXScale;\n      }\n    }\n    if (fabs(static_cast<float>(myblockfunction_destination_x_y_r_at_power_speed__y - CurrentYAxis)) < 10.0) {\n      DriveYDir = 0.0;\n    }\n    else {\n      if (myblockfunction_destination_x_y_r_at_power_speed__y - CurrentYAxis < 0.0) {\n        DriveYDir = 1.0 * DriveYScale;\n      }\n      else {\n        DriveYDir = -1.0 * DriveYScale;\n      }\n    }\n    if (fabs(static_cast<float>(TangentialDist)) < 10.0) {\n      DriveRPower = 0.0;\n    }\n    else {\n      if (TangentialDist < 0.0) {\n        DriveRPower = 1.0 * DriveRScale;\n      }\n      else {\n        DriveRPower = -1.0 * DriveRScale;\n      }\n    }\n    // Calculate motor powers over trig values\n    DriveXPower = (DriveYDir * sin(Gyroscope.heading(degrees) * M_PI / 180) + (DriveXDir * cos(Gyroscope.heading(degrees) * M_PI / 180)) * -1.0) * 1.0;\n    DriveYPower = (DriveYDir * cos(Gyroscope.heading(degrees) * M_PI / 180) + DriveXDir * sin(Gyroscope.heading(degrees) * M_PI / 180)) * 1.0;\n    // Apply motor powers to individual motors\n    myblockfunction_drive_motos_at_x_y_r_s_x_y_r_s(DriveXPower, DriveYPower, DriveRPower, myblockfunction_destination_x_y_r_at_power_speed__speed * (RampUp * RampDown));\n    myblockfunction_Print_XYR();\n  wait(5, msec);\n  }\n  myblockfunction_drive_motos_at_x_y_r_s_x_y_r_s(0.0, 0.0, 0.0, 0.0);\n}\n\n// User defined function\nvoid myblockfunction_waypoint_x_y_r_at_power_speed(double myblockfunction_waypoint_x_y_r_at_power_speed__x, double myblockfunction_waypoint_x_y_r_at_power_speed__y, double myblockfunction_waypoint_x_y_r_at_power_speed__r, double myblockfunction_waypoint_x_y_r_at_power_speed__speed) {\n  RampUp = 0.01;\n  TangentialDist = 0.0;\n  RampDown = 1.0;\n  myblockfunction_Calculate_Degrees_to_deg_from_gyro_reading(myblockfunction_waypoint_x_y_r_at_power_speed__r);\n  TangentialDist = 2.0 * (DegreeDiff * 6.2831);\n  if (0.15 < FL.velocity(percent) || (0.15 < RL.velocity(percent) || (0.15 < FR.velocity(percent) || 0.15 < RR.velocity(percent)))) {\n    RampUp = 1.0;\n  }\n  while (!((fabs(static_cast<float>(myblockfunction_waypoint_x_y_r_at_power_speed__y - CurrentYAxis)) < 50.0 && fabs(static_cast<float>(TangentialDist)) < 50.0) && fabs(static_cast<float>(myblockfunction_waypoint_x_y_r_at_power_speed__x - CurrentXAxis)) < 50.0)) {\n    // Calculate Odometry\n    myblockfunction_Poll_Absolute_Cords();\n    myblockfunction_Calculate_Degrees_to_deg_from_gyro_reading(myblockfunction_waypoint_x_y_r_at_power_speed__r);\n    TangentialDist = 2.0 * (DegreeDiff * 6.2831);\n    // Calculate Ramp Powers\n    RampUp = RampUp * 1.06;\n    if (1.0 < RampUp) {\n      RampUp = 1.0;\n    }\n    // Calculate Scale for direct line\n    if (fabs(static_cast<float>(myblockfunction_waypoint_x_y_r_at_power_speed__x - CurrentXAxis)) < fabs(static_cast<float>(TangentialDist)) && fabs(static_cast<float>(myblockfunction_waypoint_x_y_r_at_power_speed__y - CurrentYAxis)) < fabs(static_cast<float>(TangentialDist))) {\n      DriveYScale = 100.0 * (fabs(static_cast<float>(myblockfunction_waypoint_x_y_r_at_power_speed__y - CurrentYAxis)) / fabs(static_cast<float>(TangentialDist)));\n      DriveXScale = 100.0 * (fabs(static_cast<float>(myblockfunction_waypoint_x_y_r_at_power_speed__x - CurrentXAxis)) / fabs(static_cast<float>(TangentialDist)));\n      DriveRScale = 50.0;\n    }\n    else {\n      if (fabs(static_cast<float>(myblockfunction_waypoint_x_y_r_at_power_speed__x - CurrentXAxis)) < fabs(static_cast<float>(myblockfunction_waypoint_x_y_r_at_power_speed__y - CurrentYAxis))) {\n        DriveYScale = 100.0;\n        DriveXScale = 100.0 * (fabs(static_cast<float>(myblockfunction_waypoint_x_y_r_at_power_speed__x - CurrentXAxis)) / fabs(static_cast<float>(myblockfunction_waypoint_x_y_r_at_power_speed__y - CurrentYAxis)));\n        DriveRScale = 50.0 * (fabs(static_cast<float>(TangentialDist)) / fabs(static_cast<float>(myblockfunction_waypoint_x_y_r_at_power_speed__y - CurrentYAxis)));\n      }\n      else {\n        DriveYScale = 100.0 * (fabs(static_cast<float>(myblockfunction_waypoint_x_y_r_at_power_speed__y - CurrentYAxis)) / fabs(static_cast<float>(myblockfunction_waypoint_x_y_r_at_power_speed__x - CurrentXAxis)));\n        DriveXScale = 100.0;\n        DriveRScale = 50.0 * (fabs(static_cast<float>(TangentialDist)) / fabs(static_cast<float>(myblockfunction_waypoint_x_y_r_at_power_speed__x - CurrentXAxis)));\n      }\n    }\n    // Solve for direction\n    if (fabs(static_cast<float>(myblockfunction_waypoint_x_y_r_at_power_speed__x - CurrentXAxis)) < 50.0) {\n      DriveXDir = 0.0;\n    }\n    else {\n      if (myblockfunction_waypoint_x_y_r_at_power_speed__x - CurrentXAxis < 0.0) {\n        DriveXDir = 1.0 * DriveXScale;\n      }\n      else {\n        DriveXDir = -1.0 * DriveXScale;\n      }\n    }\n    if (fabs(static_cast<float>(myblockfunction_waypoint_x_y_r_at_power_speed__y - CurrentYAxis)) < 50.0) {\n      DriveYDir = 0.0;\n    }\n    else {\n      if (myblockfunction_waypoint_x_y_r_at_power_speed__y - CurrentYAxis < 0.0) {\n        DriveYDir = 1.0 * DriveYScale;\n      }\n      else {\n        DriveYDir = -1.0 * DriveYScale;\n      }\n    }\n    if (fabs(static_cast<float>(TangentialDist)) < 50.0) {\n      DriveRPower = 0.0;\n    }\n    else {\n      if (TangentialDist < 0.0) {\n        DriveRPower = 1.0 * DriveRScale;\n      }\n      else {\n        DriveRPower = -1.0 * DriveRScale;\n      }\n    }\n    // Calculate motor powers over trig values\n    DriveXPower = (DriveYDir * sin(Gyroscope.heading(degrees) * M_PI / 180) + (DriveXDir * cos(Gyroscope.heading(degrees) * M_PI / 180)) * -1.0) * 1.0;\n    DriveYPower = (DriveYDir * cos(Gyroscope.heading(degrees) * M_PI / 180) + DriveXDir * sin(Gyroscope.heading(degrees) * M_PI / 180)) * 1.0;\n    // Apply motor powers to individual motors\n    myblockfunction_drive_motos_at_x_y_r_s_x_y_r_s(DriveXPower, DriveYPower, DriveRPower, myblockfunction_waypoint_x_y_r_at_power_speed__speed * (RampUp * 1.0));\n    myblockfunction_Print_XYR();\n  wait(5, msec);\n  }\n  myblockfunction_drive_motos_at_x_y_r_s_x_y_r_s(0.0, 0.0, 0.0, 0.0);\n}\n\n// User defined function\nvoid myblockfunction_Calculate_Degrees_to_deg_from_gyro_reading(double myblockfunction_Calculate_Degrees_to_deg_from_gyro_reading__deg) {\n  if (fabs(static_cast<float>(Gyroscope.heading(degrees) - myblockfunction_Calculate_Degrees_to_deg_from_gyro_reading__deg)) > 180.0) {\n    DegreeDiff = ((Gyroscope.heading(degrees) - myblockfunction_Calculate_Degrees_to_deg_from_gyro_reading__deg) - 360.0) * -1.0;\n  }\n  else {\n    DegreeDiff = Gyroscope.heading(degrees) - myblockfunction_Calculate_Degrees_to_deg_from_gyro_reading__deg;\n  }\n}\n\n// User defined function\nvoid myblockfunction_Poll_Absolute_Cords() {\n  DeltaTheta = Gyroscope.heading(degrees) - PreviousTheta;\n  EncoderDeltaY = y.rotation(degrees) - PreviousYValue;\n  EncoderDeltaX = (x.rotation(degrees) - 0.0) - PreviousXValue;\n  PreviousXValue = x.rotation(degrees) - 0.0;\n  PreviousYValue = y.rotation(degrees);\n  PreviousTheta = Gyroscope.heading(degrees);\n  // Dont do this but checks for 360 deg wrap\n  // then gives delta theta an average change ammount.\n  // may cause slight error\n  if (DeltaTheta > 300.0) {\n    DeltaTheta = 0.5;\n  }\n  if (-300.0 > DeltaTheta) {\n    DeltaTheta = -0.5;\n  }\n  CurrentXAxis = CurrentXAxis + ((EncoderDeltaY * sin(Gyroscope.heading(degrees) * M_PI / 180)) * -1.0 + (EncoderDeltaX - DeltaTheta * -1.60520825) * cos(Gyroscope.heading(degrees) * M_PI / 180)) * 0.609;\n  CurrentYAxis = CurrentYAxis + ((EncoderDeltaY * cos(Gyroscope.heading(degrees) * M_PI / 180) + (EncoderDeltaX - DeltaTheta * -1.60520825) * sin(Gyroscope.heading(degrees) * M_PI / 180)) * 0.609) * -1.0;\n}\n\n// Used to find the format string for printing numbers with the\n// desired number of decimal places\nconst char* printToConsole_numberFormat() {\n  // look at the current precision setting to find the format string\n  switch(Console_precision){\n    case 0:  return \"%.0f\"; // 0 decimal places (1)\n    case 1:  return \"%.1f\"; // 1 decimal place  (0.1)\n    case 2:  return \"%.2f\"; // 2 decimal places (0.01)\n    case 3:  return \"%.3f\"; // 3 decimal places (0.001)\n    default: return \"%f\"; // use the print system default for everthing else\n  }\n}\n\n// User defined function\nvoid myblockfunction_Print_XYR() {\n  printf(\"X\");\n  printf(printToConsole_numberFormat(), static_cast<float>(CurrentXAxis));\n  printf(\",Y\");\n  printf(printToConsole_numberFormat(), static_cast<float>(CurrentYAxis));\n  printf(\",R\");\n  printf(printToConsole_numberFormat(), static_cast<float>(RampDown));\n  printf(\"\\n\");\n}\n\n// User defined function\nvoid myblockfunction_Lock_Base() {\n  BaseLock.spinToPosition(45.0, degrees, false);\n}\n\n// User defined function\nvoid myblockfunction_Unlock_Base() {\n  BaseLock.spinToPosition(0.0, degrees, false);\n}\n\n// User defined function\nvoid myblockfunction_drive_motos_at_x_y_r_s_x_y_r_s(double myblockfunction_drive_motos_at_x_y_r_s_x_y_r_s__x, double myblockfunction_drive_motos_at_x_y_r_s_x_y_r_s__y, double myblockfunction_drive_motos_at_x_y_r_s_x_y_r_s__r, double myblockfunction_drive_motos_at_x_y_r_s_x_y_r_s__s) {\n  if (!(myblockfunction_drive_motos_at_x_y_r_s_x_y_r_s__x == 0.0) || (!(myblockfunction_drive_motos_at_x_y_r_s_x_y_r_s__y == 0.0) || !(myblockfunction_drive_motos_at_x_y_r_s_x_y_r_s__r == 0.0))) {\n    FL.setVelocity((((myblockfunction_drive_motos_at_x_y_r_s_x_y_r_s__y * myblockfunction_drive_motos_at_x_y_r_s_x_y_r_s__s + myblockfunction_drive_motos_at_x_y_r_s_x_y_r_s__r * myblockfunction_drive_motos_at_x_y_r_s_x_y_r_s__s) - myblockfunction_drive_motos_at_x_y_r_s_x_y_r_s__x * myblockfunction_drive_motos_at_x_y_r_s_x_y_r_s__s) + 0.0), percent);\n    FL.spin(forward);\n    RL.setVelocity((((myblockfunction_drive_motos_at_x_y_r_s_x_y_r_s__y * myblockfunction_drive_motos_at_x_y_r_s_x_y_r_s__s + myblockfunction_drive_motos_at_x_y_r_s_x_y_r_s__r * myblockfunction_drive_motos_at_x_y_r_s_x_y_r_s__s) + myblockfunction_drive_motos_at_x_y_r_s_x_y_r_s__x * myblockfunction_drive_motos_at_x_y_r_s_x_y_r_s__s) + 0.0), percent);\n    RL.spin(forward);\n    FR.setVelocity((((myblockfunction_drive_motos_at_x_y_r_s_x_y_r_s__y * myblockfunction_drive_motos_at_x_y_r_s_x_y_r_s__s - myblockfunction_drive_motos_at_x_y_r_s_x_y_r_s__r * myblockfunction_drive_motos_at_x_y_r_s_x_y_r_s__s) + myblockfunction_drive_motos_at_x_y_r_s_x_y_r_s__x * myblockfunction_drive_motos_at_x_y_r_s_x_y_r_s__s) - 0.0), percent);\n    FR.spin(forward);\n    RR.setVelocity((((myblockfunction_drive_motos_at_x_y_r_s_x_y_r_s__y * myblockfunction_drive_motos_at_x_y_r_s_x_y_r_s__s - myblockfunction_drive_motos_at_x_y_r_s_x_y_r_s__r * myblockfunction_drive_motos_at_x_y_r_s_x_y_r_s__s) - myblockfunction_drive_motos_at_x_y_r_s_x_y_r_s__x * myblockfunction_drive_motos_at_x_y_r_s_x_y_r_s__s) - 0.0), percent);\n    RR.spin(forward);\n  }\n  else {\n    FL.stop();\n    RL.stop();\n    FR.stop();\n    RR.stop();\n  }\n}\n\n// \"when autonomous\" hat block\nint onauton_autonomous_0() {\n  Gyroscope.startCalibration();\n  while (Gyroscope.isCalibrating()) { task::sleep(50); }\n  Gyroscope.setHeading(180.0, degrees);\n  // pickup red\n  myblockfunction_Send_Lift_to_position_r(-600.0);\n  myblockfunction_destination_x_y_r_at_power_speed(3260.0, 550.0, 180.0, 0.6);\n  LiftLeft.stop();\n  LiftRight.stop();\n  myblockfunction_Lock_Base();\n  wait(0.15, seconds);\n  myblockfunction_Unlock_Base();\n  wait(0.15, seconds);\n  myblockfunction_Lock_Base();\n  myblockfunction_Send_Lift_to_position_r(0.0);\n  // drop red\n  myblockfunction_waypoint_x_y_r_at_power_speed(3260.0, 2000.0, 180.0, 0.7);\n  myblockfunction_destination_x_y_r_at_power_speed(2700.0, 2400.0, 90.0, 0.6);\n  myblockfunction_Send_Lift_to_position_r(-600.0);\n  myblockfunction_Unlock_Base();\n  myblockfunction_destination_x_y_r_at_power_speed(3220.0, 2400.0, 90.0, 0.7);\n  // pickup blue\n  myblockfunction_waypoint_x_y_r_at_power_speed(3250.0, 3300.0, 90.0, 0.5);\n  myblockfunction_destination_x_y_r_at_power_speed(2935.0, 3300.0, 90.0, 0.4);\n  myblockfunction_Lock_Base();\n  myblockfunction_Send_Lift_to_position_r(600.0);\n  myblockfunction_waypoint_x_y_r_at_power_speed(3250.0, 3220.0, 90.0, 0.5);\n  myblockfunction_waypoint_x_y_r_at_power_speed(2820.0, 2400.0, 90.0, 0.7);\n  // bulldoze yellow 1\n  myblockfunction_waypoint_x_y_r_at_power_speed(2820.0, 900.0, 90.0, 0.7);\n  myblockfunction_destination_x_y_r_at_power_speed(2820.0, 1100.0, 90.0, 0.7);\n  // spin move blue\n  myblockfunction_Unlock_Base();\n  myblockfunction_Send_Lift_to_position_r(-600.0);\n  myblockfunction_waypoint_x_y_r_at_power_speed(2500.0, 1100.0, 300.0, 0.7);\n  myblockfunction_waypoint_x_y_r_at_power_speed(1800.0, 1100.0, 270.0, 0.7);\n  // bulldoze yellow 2\n  myblockfunction_waypoint_x_y_r_at_power_speed(1780.0, 1300.0, 270.0, 0.7);\n  myblockfunction_waypoint_x_y_r_at_power_speed(1780.0, 2300.0, 270.0, 0.7);\n  myblockfunction_waypoint_x_y_r_at_power_speed(1300.0, 2300.0, 270.0, 0.7);\n  // pickup blue\n  myblockfunction_waypoint_x_y_r_at_power_speed(1200.0, 2775.0, 90.0, 0.7);\n  myblockfunction_destination_x_y_r_at_power_speed(800.0, 2775.0, 90.0, 0.4);\n  myblockfunction_Lock_Base();\n  myblockfunction_Send_Lift_to_position_r(1.0);\n  // yellow number 3\n  myblockfunction_waypoint_x_y_r_at_power_speed(1130.0, 2300.0, 270.0, 0.7);\n  myblockfunction_waypoint_x_y_r_at_power_speed(1130.0, 1100.0, 270.0, 0.7);\n  // drop blue 2\n  myblockfunction_destination_x_y_r_at_power_speed(1400.0, 1100.0, 300.0, 0.4);\n  myblockfunction_Unlock_Base();\n  myblockfunction_Send_Lift_to_position_r(-600.0);\n  myblockfunction_waypoint_x_y_r_at_power_speed(1130.0, 1200.0, 270.0, 0.6);\n  myblockfunction_waypoint_x_y_r_at_power_speed(350.0, 1200.0, 270.0, 0.5);\n  // pick red\n  myblockfunction_waypoint_x_y_r_at_power_speed(350.0, 500.0, 270.0, 0.5);\n  myblockfunction_destination_x_y_r_at_power_speed(610.0, 500.0, 270.0, 0.4);\n  myblockfunction_Lock_Base();\n  myblockfunction_Send_Lift_to_position_r(600.0);\n  myblockfunction_waypoint_x_y_r_at_power_speed(350.0, 500.0, 270.0, 0.7);\n  // yeet\n  myblockfunction_destination_x_y_r_at_power_speed(430.0, 2600.0, 270.0, 0.7);\n  myblockfunction_Unlock_Base();\n  myblockfunction_Send_Lift_to_position_r(-600.0);\n  return 0;\n}\n\n// \"when driver control\" hat block\nint ondriver_drivercontrol_0() {\n  while (true) {\n    myblockfunction_ManualControl();\n    myblockfunction_Manuel_Other_Functions();\n  wait(5, msec);\n  }\n  return 0;\n}\n\n// \"when started\" hat block\nint whenStarted1() {\n  myblockfunction_Set_Offset_x_y(3355.0, 230.0);\n  Console_precision = -1;\n  PreviousTheta = 180.0;\n  PreviousXValue = x.rotation(degrees);\n  PreviousYValue = y.rotation(degrees);\n  ForwardMultiplier = 0.8;\n  TranslateMultiplier = 0.7;\n  TurnMultiplier = 0.5;\n  FL.setStopping(brake);\n  RL.setStopping(brake);\n  FR.setStopping(brake);\n  RR.setStopping(brake);\n  RL.setMaxTorque(100.0, percent);\n  FR.setMaxTorque(100.0, percent);\n  FL.setMaxTorque(100.0, percent);\n  RR.setMaxTorque(100.0, percent);\n  LiftLeft.setMaxTorque(100.0, percent);\n  LiftRight.setMaxTorque(100.0, percent);\n  LiftLeft.setVelocity(100.0, percent);\n  LiftRight.setVelocity(100.0, percent);\n  LiftLeft.setStopping(brake);\n  LiftRight.setStopping(brake);\n  BaseLock.setVelocity(100.0, percent);\n  BaseLock.setStopping(brake);\n  return 0;\n}\n\nvoid VEXcode_driver_task() {\n  // Start the driver control tasks....\n  vex::task drive0(ondriver_drivercontrol_0);\n  while(Competition.isDriverControl() && Competition.isEnabled()) {this_thread::sleep_for(10);}\n  drive0.stop();\n  return;\n}\n\nvoid VEXcode_auton_task() {\n  // Start the auton control tasks....\n  vex::task auto0(onauton_autonomous_0);\n  while(Competition.isAutonomous() && Competition.isEnabled()) {this_thread::sleep_for(10);}\n  auto0.stop();\n  return;\n}\n\n\n\nint main() {\n  vex::competition::bStopTasksBetweenModes = false;\n  Competition.autonomous(VEXcode_auton_task);\n  Competition.drivercontrol(VEXcode_driver_task);\n\n  // post event registration\n\n  // set default print color to black\n  printf(\"\\033[30m\");\n\n  // wait for rotation sensor to fully initialize\n  wait(30, msec);\n\n  whenStarted1();\n}","textLanguage":"cpp","rconfig":[{"port":[19],"name":"FL","customName":true,"deviceType":"Motor","deviceClass":"motor","setting":{"reversed":"false","fwd":"forward","rev":"reverse","gear":"ratio18_1"},"triportSourcePort":22},{"port":[20],"name":"RL","customName":true,"deviceType":"Motor","deviceClass":"motor","setting":{"reversed":"false","fwd":"forward","rev":"reverse","gear":"ratio18_1"},"triportSourcePort":22},{"port":[9],"name":"FR","customName":true,"deviceType":"Motor","deviceClass":"motor","setting":{"reversed":"true","fwd":"forward","rev":"reverse","gear":"ratio18_1"},"triportSourcePort":22},{"port":[10],"name":"RR","customName":true,"deviceType":"Motor","deviceClass":"motor","setting":{"reversed":"true","fwd":"forward","rev":"reverse","gear":"ratio18_1"},"triportSourcePort":22},{"port":[],"name":"Controller1","customName":false,"deviceType":"Controller","deviceClass":"controller","setting":{"left":"","leftDir":"false","right":"","rightDir":"false","upDown":"","upDownDir":"false","xB":"","xBDir":"false","drive":"none","id":"primary"},"triportSourcePort":22},{"port":[18],"name":"Gyroscope","customName":true,"deviceType":"Inertial","deviceClass":"inertial","setting":{"id":"partner"},"triportSourcePort":22},{"port":[1,2],"name":"y","customName":true,"deviceType":"Encoder","deviceClass":"encoder","setting":{"id":"partner"},"triportSourcePort":22},{"port":[3,4],"name":"x","customName":true,"deviceType":"Encoder","deviceClass":"encoder","setting":{"id":"partner"},"triportSourcePort":22},{"port":[7],"name":"LiftLeft","customName":true,"deviceType":"Motor","deviceClass":"motor","setting":{"reversed":"false","fwd":"forward","rev":"reverse","gear":"ratio18_1"},"triportSourcePort":22},{"port":[6],"name":"LiftRight","customName":true,"deviceType":"Motor","deviceClass":"motor","setting":{"reversed":"true","fwd":"forward","rev":"reverse","gear":"ratio18_1"},"triportSourcePort":22},{"port":[17],"name":"BaseLock","customName":true,"deviceType":"Motor","deviceClass":"motor","setting":{"reversed":"true","fwd":"forward","rev":"reverse","gear":"ratio18_1"},"triportSourcePort":22}],"slot":0,"platform":"V5","sdkVersion":"20211013.15.00.00","appVersion":"2.2.1","fileFormat":"1.0.1","icon":"","targetBrainGen":"First","target":"Physical"}